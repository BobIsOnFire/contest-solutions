/*

Дана матрица n×m (n, m — степени двойки), заполненная целыми числами от 1 до nm
(числа по возрастанию по строкам). Например, для n = 4 и m = 8 матрица имеет
следующий вид:

┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │
├───┼───┼───┼───┼───┼───┼───┼───┤
│ 9 │10 │11 │12 │13 │14 │15 │16 │
├───┼───┼───┼───┼───┼───┼───┼───┤
│17 │18 │19 │20 │21 │22 │23 │24 │
├───┼───┼───┼───┼───┼───┼───┼───┤
│25 │26 │27 │28 │29 │30 │31 │32 │
└───┴───┴───┴───┴───┴───┴───┴───┘

За один шаг мы «складываем» матрицу пополам, как лист бумаги, поперек большей
стороны (по горизонтали или по вертикали) и суммируем числа, которые
накладываются друг на друга, до тех пор, пока не останется один элемент. Квадрат
складываем по горизонтальной линии. Элементы всех полученных матриц (в том числе
и исходной) выписываем в одну последовательность. Найдите количество различных
выписанных чисел.


В единственной строке входных данных записаны два числа n и m (1 ≤ nm ≤ 2^30).
Оба числа являются степенями двойки.

Выведите единственное число — количество различных выписанных чисел.
--------------------------------------------------------------------------------
Примеры:

ВВОД
1 1

ВЫВОД
1
---------------------------------------
ВВОД
1 8

ВЫВОД
11
---------------------------------------
ВВОД
4 4

ВЫВОД
21
--------------------------------------------------------------------------------
*/

#include <iostream>

unsigned int log2(unsigned int n) {
    unsigned int res = 0;
    while ((n >>= 1) > 0) res++;
    return res;
}

unsigned long pow2(unsigned int n) {
    return 1L << n;
}

unsigned long get_result(unsigned int a, unsigned int b) {
    if (b == 0)   return pow2(a+b) + pow2(b) * (a-b);
    if (a >= b)   return pow2(a+b) + pow2(b) * (a-b) + pow2(b-1) + 2*b - 1;
    if (2*a >= b) return pow2(a+b) + pow2(a) * (b-a-1) + pow2(2*a-b) + 2*a;
    return pow2(a+b) + pow2(a) * (b-a-1) + 1 + 2*a;
}

int main() {
    unsigned int n, m;
    std::cin >> n >> m;
    std::cout << get_result(log2(n), log2(m)) << "\n";
}
